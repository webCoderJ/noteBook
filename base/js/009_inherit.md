[GIT](https://github.com/ljianshu/Blog/issues/20)

- **原型链继承** `子类型的原型为父类型的一个实例对象`

  ```js
  sub.__proto__ = new Parent
  ```

  - 做到了将父类的私有、公有方法和属性都当做子类的公有属性
  - 缺点：
    - 有多个子类的时候，由于都指向了一个对象，一个子类操作父类对象的属性或方法时候(引用)，会影响其他子类的引用，即单实例
    - 无法实现多继承
    - 创建子类实例无法向父类构造器传参

- **借用构造函数继承** `在子类型构造函数中通用call()调用父类型构造函数`

  - 解决共享父类实例问题
  - 可以向父类构造器传参
  - 可以实现多继承
  - 实例不是父类实例
  - 只能继承父类实例的属性和方法，不能继承原型链方法

- **组合继承**：原型链 + 借用 组合继承 `通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用`

- **组合继承优化** `借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，生成了B对象。B继承了A的所有属性和方法。`

  - ```js
    Object.create(Person.prototype) // 关键点
    ```

- **extends**

  