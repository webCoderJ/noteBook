## 算法的时间复杂度和空间复杂度

> 算法是指用来操作数据、解决程序问题的一组方法。对于统一问题，使用不同的算法，也许得到结果是一样的，但是过程中小号的资源和事件却会有很大的区别。
>
> [参考文章](<https://blog.csdn.net/jsjwk/article/details/84315770>)

- 时间复杂度：指执行当前算法缩消耗的时间，通常用`时间复杂度`来描述。
- 空间复杂度：指执行算法需要占用多少内存空间，通常用`空间复杂度`来描述。

#### 时间复杂度

##### 算法的渐进时间复杂度： T(n) = O(f(n))

- f(n) 表示每行代码执行次数和
- O表示比例关系，表示代码执行时间的增长变化趋势

##### 常见的复杂度量级

从上至下依次的时间复杂度越来越大，执行的效率越来越低

- 常数阶O(1)

  无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

- 对数阶O(logN)

  ```js
  let i = 1;
  while(i<n)
  {
      i = i * 2;
  }
  ```

- 线性阶O(n)

  ```js
  for(i=1; i<=n; ++i)
  {
     j = i;
     j++;
  }
  ```

- 线性对数阶O(nlogN)

  ```js
  for(m=1; m<n; m++)
  {
      i = 1;
      while(i<n)
      {
          i = i * 2;
      }
  }
  ```

- 平方阶O(n²)

  ```js
  for(x=1; i<=n; x++)
  {
     for(i=1; i<=n; i++)
      {
         j = i;
         j++;
      }
  }
  ```

  这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 
  如果将其中一层循环的n改成m，即：

  ```js
  for(x=1; i<=m; x++)
  {
     for(i=1; i<=n; i++)
      {
         j = i;
         j++;
      }
  }
  ```

  那它的时间复杂度就变成了 O(m*n)

- 立方阶O(n³)

- K次方阶O(n^k)

- 指数阶(2^n)

  ```js
  let count = 0;
  function aFunc(n) { 
    	count++
      if (n <= 1) {        
          return 1;
      } else {        
          return aFunc(n - 1) + aFunc(n - 2);
      }
  }
  console.log(aFunc(50))
  console.log(count) 
  
  // 尾递归
  function fib(n, n1, n2){
      if(n === 0) {
          return n1
      }
  
      return fib(n-1, n2, n1 + n2)
  }
  ```

[尾递归Fib](https://juejin.im/post/5ab9a3ab518825558154fe83)

#### 空间复杂度 SpaceComplexity

程序运行时所需要占用的空间

#### 结语

对于一个算法，其[时间复杂度](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。

对时间复杂度的追求更是属于算法的潮流！