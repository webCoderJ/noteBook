## 1

1. 浏览器缓存
2. get post 速度 安全？
3. node全局变量
4. 节流函数 / deepclone
5. promise.then

## 2

1. 浏览器渲染过程
2. script标签加载
3. git fastforward
4. 跨域

## 总结

面试时间：2018-03-26
结果：失败
早早的坐了一个小时的地铁，提前一个小时到了公司楼下。由于是上班高峰期等电梯的人实在有点多，足足二十分钟后我才到了19层的人人车前台。
这次面试其实是很有信心的，第一轮面试是一个妹子，应该是前端组长(厉害啊！)。
感觉她提的问题基本都回答的还不错，而且过程中聊的还挺好。
可能是妹子吧，面试的时候没有紧张的情绪。
开始是常规的自我介绍，大概说了下工作经验，以及我做的项目和技术栈等等。
因为总体答的还不错主要总结一下答的不好的题。
Q: 你能说说浏览器的缓存吗？还有协商缓存和强制缓存。
A: 这个由于平时没怎么使用(OS:就是不会啊)，所有没有仔细去研究它(这样的回答直接凉凉...)我只知道服务器返回304的时候是告诉浏览器资源没有改变是直接在浏览器的缓存中取。
Q: 那你说一下状态码吧
A: 我就说了一下状态码的分类，还有常用的几个状态码的作用。

| 分类   | 描述                                |
| ---- | --------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作            |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求                 |
| 4**  | 客户端错误，请求包含语法错误或由于服务端的错误，服务器无法完成请求 |
| 5**  | 服务器错误，服务器在处理请求的过程中发生错误            |

常用的状态码

| CODE | 英文名称                       | 描述                                       |
| ---- | -------------------------- | ---------------------------------------- |
| 100  | Continue                   | 继续，服务器收到请求。客户端应继续请求                      |
|      |                            |                                          |
| 200  | OK                         | 请求成功，一般用于GET/POST请求                      |
|      |                            |                                          |
| 301  | Moved Permanently          | 永久移动，请求的资源已经被永久移动到新的URI，服务器返回一个新的URI，浏览器会自动定向到新URI。 |
| 302  | Found                      | 临时移动，与301类似。但资源只是临时移动。客户端应继续使用原有URI      |
| 304  | Not-Modified               | 资源未修改                                    |
|      |                            |                                          |
| 400  | Bad Request                | 客户端请求的语法错误，服务器无法理解                       |
| 403  | Forbidden                  | 服务器理解客户端请求，但是拒绝执行                        |
| 404  | Not Found                  | 服务器找不到请求资源。                              |
| 405  | Method Not Allowed         | 客户端请求方式被禁止                               |
|      |                            |                                          |
| 500  | Internal Server            | 服务器内部错误，无法完成请求                           |
| 501  | Not Implemented            | 服务器不支持请求的功能，无法完成请求                       |
| 502  | Bad Gateway                | 充当网关或代理服务器，从远端服务器收到了一个无效的请求              |
| 504  | Gateway Time-out           | 充当网关的代理服务器，未及时从远端服务器获取请求                 |
| 505  | HTTP Version not supported | 服务器不支持请求的HTTP协议版本                        |

有点跑题了，回到主题

- 缓存的好处
  - 前端
    - 减少呈现时间
  - 后端
    - 减少带宽
    - 减少并发


- 强缓存
  - 用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不和服务器发生交互
- 协商缓存
  - 用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源
- 共同点：客户端获得的数据最后都是从客户端缓存中获得
- 区别：从名字可以看出，一个与服务器交互，一个不做交互
- 强缓存命中（expires + cache-control）：
  - expires: 过期时间(服务器时间)，浏览器时间和服务器时间不一致的时候会有问题
  - cache-control (缓存控制)
    - max-age: 缓存的最大有效时间(s)，相对与缓存的Date字段(本次缓存的服务器时间)
    - s-maxage: 用于共享缓存，比如CDN缓存。如果存在会覆盖max-age
    - public：响应会被缓存，并且在多用户之间共享，浏览器默认有这个字段
    - private：响应只作为私有的缓存，不能在不同用户之间共享。要求HTTP认证(浏览器怎么区分这里的用户的？通过IP? refference?)
    - no-cache：指定不做缓存，表明资源不做缓存，但是不代表浏览器不做缓存，而是缓存钱要向服务器确认资源是否被更改，因此服务器在设置不缓存时候仅仅设置no-cache还不够保险。可以加上private指令，将过期时间设置为过去的时间
    - no-store：绝对禁止缓存
    - must-revalidate：如果页面过期，则去服务器进行获取
  - 当应用访问一个资源时，浏览器会先检查 chrome://cache(chrome为例)中是否有当前路径，如果有：
    - 对比expire与当前浏览器时间，如果未过期，则从缓存中获取
    - 如果有cache-control字段，对比max-age/s-maxage与Date字段(服务器缓存时间)，如果未过期，则命中强缓存
- 协商缓存
  - 未命中强缓存的时候，浏览器会向服务器发起资源请求。在请求头中会携带以下信息：
    - Last-modified:
    - If-Modified-Since:
    - Etag: 资源的内容hash
    - If-None-Match: 客户端保留的内容hash
  - 服务器决策：服务器校验这些信息，返回响应状态，浏览器会根据情况做相应操作
    - 304：Not-Modified -> 从缓存中获取内容
    - 资源
- 公司现存的问题
  - 每次更新所有文件的 hash都会发生改变？
  - scss代码的冗余
  - 没有做强缓存(node？nginx？cdn？)
  - 上线时候的覆盖式更新，怎么改为非覆盖式更新？
    - 先上传了client包 (包含了新版本客户端所有的文件)
    - pull服务器的修改
    - pm2 restart server

Q：get post的区别？安全性和速度？

A：get post带参数的问题…GG，真的对对http了解的太少了...

[参考链接](http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml) (写的贼6)

其实从TCP/IP协议上来看，GET/POST是没有区别的，只是拿来传送数据和获取数据的链接

HTTP对TCP/IP传输做了很多限制，以达到语义化和区分传输类别的作用

直观区别

|       | GET               | POST                                     |
| ----- | ----------------- | ---------------------------------------- |
| 参数位置  | URL中              | request body，其实get也可以在body中添加参数，只不过一般服务器不会处理 |
| 参数大小  | 2K(服务器最多处理64K的大小) | 没有限制                                     |
| 浏览器缓存 | true              | false                                    |
| 历史记录  | true              | false                                    |
| 参数编码  | ASCII             | 没有限制                                     |
|       |                   | 内在区别 内在区别 内在区别 内在区别                      |
| 数据包   | 1 header + data   | 2 (第一次发送) header 给服务器，服务器响应100，然后发送第二个包 body 给服务器，但是但是但是并不是所有浏览器都会这样做，firefox会将两个数据一次性发送给服务器 |
| 速度    | ++                | +                                        |



node 全局变量

- REPL中的全局变量
  - global
  - console
  - process
- 全局函数
  - setTimeout setInterval clearTimeout clearInterval
  - console
  - require
- 全局变量
  - __dirname
  - __filename

```javascript
// 问题是promise的使用方法以及promise的一个then中抛出了错误，下面的then还会执行吗？
// 这个问题面试的时候是回答对了的，但是由于记得不是很清楚，回答的没有多大自信，所以验证一下

var pro = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('promise resolved!')
    }, 1000)
})

pro
    .then(data => {
        console.log('then 1', data)

        return {
            then: 'then1',
            data: data
        }
        // 已经return 不会执行...
        throw new Error('then 1 err')
    })
    .then(data => {
        // 可以执行到
        console.log('then2', data)
    })


pro
    .then(data => {
        console.log('then 1')
        throw new Error('then 1 err')
    })

    .then(data => {
        console.log('then2')
    }, err => {
        console.log('then2 err')
        console.log(err)
    })

    // then 1 promise resolved!
    // VM177:28 then 1
    // VM177:22 then2 {then: "then1", data: "promise resolved!"}
    // VM177:36 then2 err
    // VM177:37 Error: then 1 err
    //     at pro.then.data (<anonymous>:29:15)

/**
 * 结论： 当在then1中抛出错误的时候，then2中的err方法会被触发执行
 */
```

第二轮面试

浏览器渲染过程 [zh](https://kb.cnblogs.com/page/129756/)  [en](http://taligarsiel.com/Projects/howbrowserswork1.htm#Parser_Lexer_combination)

